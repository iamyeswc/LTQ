# LTQ
A lightweight, high-concurrency message middleware.

利用golang原生并发，实现高性能的消息流处理

1. goroutine 并发
2. chan 消息存储

---

## NO SPOF 分布式

- C：一致性 RAFT
- A：可用性 √
- P：分区容错性 √

## 服务发现

- 服务器发现：客户端请求首先发送到负载均衡器，由负载均衡器查询注册中心转发请求，需要额外维护负载均衡器或网关
- 客户端发现：客户端从服务注册中心查询可用实例，根据一个负载均衡算法选择一个可用的服务实例发起请求

采用客户端发现，客户端去注册中心查找可用节点，随机选取一个。

---

## 消息模型

- 一个生产者对一个消费者

   1：1， 消息有序

- 多个生产者将消息送到topic, 订阅了topic的消费者拿到消息

   多：1

-  生产者将消息送到topic, topic下有多个channel, 订阅了channel的消费者拿到消息

   多：多

---

## 消息推送和拉取

- pull：按需，批量，但会出现空拉，实时差
- push：实时性，但需要客户端做限流

---

## 消息投递

- 至少一次
- 至多一次
- 准确一次

## 消息的顺序性

生产者从注册中心获取实例推送消息时，将已有的topic的节点的地址返回给生产者。如果没有对应的topic则随机选择一个节点。这样可以保证一个 topic 只存在一个节点，从而确保消息的顺序性。